# spectrometer
Simulation of a mass spectrometer (Giudici's exam)


## Overview of things to be done

| Compito                                                                                                                                                        | Richiesta precisa                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| generare pk e vita K(usando le opportune distribuzioni)verificare che tornino con dei plot                                                                     | double genera_ev_energia() { //restituisce un'energia da gauss}double genera_ev_cammino() { //restituisce un cammino da exp}grafico numero-energia (gauss)grafico numero-cammino (exp)l'energia è gauss(media=100, sigma=30)il cammino è exp(l) dove l dipende dall'energia e dai parametri del K// deve runnare per N volte, dove N si può cambiare                                                                                                                                                                                                                                                                                                                   |
| Generare angolo del decadimento nel CM(distribuzione uniforme dell'angolo) e cambiare ilriferimento restituendo gli impulsi dei due pi nelsist del laboratorio | double p_cm //valore dell'impulso nel cm, dai contidouble th_cm() {//restituisce un valido theta}double th1(double th_cm, double pk) {//porta l'angolo nel lab}double p1(double p_cm, double pk) {//porta l'impulso nel lab}double th2(double th_cm, double pk) {//porta l'angolo nel lab}double p2(double p_cm, double pk) {//porta l'impulso nel lab}grafici di tutte le quantità che fanno vedere che tutto torni                                                                                                                                                                                                                                                   |
| "Disegnare i rivelatori"Trovare l'intersezione tra la traiettoria e i primidue detector                                                                        | // decidere a che z1...z4 mettere i rivelatori (basandosi su numeri che abbiano senso)double x11(th1){ // punto di pi1 sul detector a z1 }double x12(th1){ // punto di pi1 sul detector a z2 }double x21(th1){ // punto di pi2 sul detector a z1 }double x22(th1){ // punto di pi2 sul detector a z2 }grafici di tutte le quantità per vedere che tutto torni                                                                                                                                                                                                                                                                                                          |
| Ruotare di \phi                                                                                                                                                | // decidere lo smearing da applicare a x e y (di nuovo, che abbia senso)// questo vale per ogni x11, x12, x21, x22double phi(){ // genera \phi con l'apposita distrib}double xf11(x11) {ruota x11 di \phi}double yf11(x11) {ruota x11 di \phi}// applicare a tutti lo smearing// grafici di tutto quanto                                                                                                                                                                                                                                                                                                                                                               |
| p_kicktrovare le intersezioni con i secondi rivelatori                                                                                                         | // dare un valore (sensato) a p_kickdouble xf13(....) {// trova x sul rivelatore a z3}// così via per tutte le coordinate (8 in totale)// grafici di tutto quanto                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|                                                                                                                                                                | State of the art:a questo punto dobbiamo avere la seguente struttura dati,che useremo anche per l'altro programma:double x[rivelatore][evento] una matrice da 4 righe e N colonnedouble y[rivelatore][evento] una matrice da 4 righe e N colonneDa tenersi per controllare:double z[evento] un vettore da N elementi (punto di decad)double pk[evento] un vettore da N elementi (energia K)                                                                                                                                                                                                                                                                            |
| Scrivere su file e leggere i dati da file(fra i due programmi diversi)                                                                                         | scrivere un file tipo:x11 x12 x13 x14 x21 x22 x23 x24 y11 y12 y13 y14 y21 y22 y23 y24 - z pk th1 th2 p1 p2x11 x12 x13 x14 x21 x22 x23 x24 y11 y12 y13 y14 y21 y22 y23 y24 - z pk th1 th2 p1 p2.....lungo N, che contenga tutti i dati sperimentali (prime 8) e i dati veri (ultime 6) che ci consentono di controllaredovete fare la versione che legge e quella che scrive tra i due programmi,potete scegliere quindi il formato che volete (se volete aggiungere trattini, più righe, eccbasta che sia un file di testo ascii ben comprensibile all'occhio umano)potete anche usare %a quando si scrive su file per essere sicuri di non rovinare i dati,vedete voi |
| Stimare P dato l'angolo di deviazione \delta\theta                                                                                                             | double delta_theta(x11, x12, x13, x14, y11, y12, y13, y14) {//calcola delta_theta1}double p1(delta_theta) { // trova l'impulso}// stesso per il secondo pione                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| Trovare il punto z di minima distanza delle rettee propagare l'errore (formula analitica)                                                                      | double z(x11, x12, ....) {// restituisce il punto d'impatto migliore}double delta_z(....) {//fa l'errore su z con la formula opportuna}// vedere che torni con il generato// grafici di z -> stima della vita media del K// grafico di z_ricostr - z_vero, vedere se abbiamo fatto un buon lavoro                                                                                                                                                                                                                                                                                                                                                                      |
| Trovare la massa invariante e l'energia del k                                                                                                                  | M(x1,.....) {// ricostruisce la massa invariante}pk(x1.........) {// ricostruisce l'energia del K}// grafici di tutte e 2, deve venire bene//grafici di cosa_ricostr - cosa_vera, vediamo se siamo stati bravi                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
